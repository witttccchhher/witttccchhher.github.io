---
title: Введение
---
import {
  AnimatedSpan,
  Terminal,
  TypingAnimation,
} from "@/components/magicui/terminal";

Nix - это функциональный менеджер пакетов, который кардинально отличается по принципу работы от классических пакетных менеджеров, таких как dnf, apt, pacman и т.п.

На данный момент репозиторий пакетов [nixpkgs](https://github.com/NixOS/nixpkgs) насчитывает около **120 тысяч** пакетов, являясь неоспоримым лидером. Для сравнения репозиторий [AUR](https://aur.archlinux.org) содержит около 90 тысяч пакетов.

В традиционных пакетных менеджерах во время установки какого-либо ПО, состояние системы меняется на ходу, то есть файлы новых версий программ записываются поверх существующих, заменясь новыми.
Как следствие, невозможно иметь несколько версий одной и той же программы в одной системе.

<Callout>Конечно, существуют способы сделать это (контейнеры, виртуальные оболочки), но они слишком сложны или ресурсозатратны, чтобы использовать их.</Callout>

Хоть такой подход и проще в плане архитектуры и работы, он вызывает множество проблем связанных с различными версиями пакетов и их взаимодействием между собой. В традиционных пакетных менеджерах часто возникает ситуация, когда одно приложение зависит от более старой версии библиотеки, в то время как другие требуют установки новой версии.

<Callout>В сообществе такую проблему называют **адом зависимостей** (_dependency hell_).</Callout>

Что же делать в такой ситуации? Пакетный менеджер Nix элегантно решает эти и другие проблемы путем нескольких решений, речь о которых пойдет далее.

# Изолирование пакетов
Начнем с того, что Nix изолирует каждый пакет в системе в свою отдельную директорию, название которой содержит свое уникальное криптографическое **hash-значение**, имя пакета и его версию.

<Callout>На самом деле для пакетного менеджера Nix имеет значение только само hash-значение, а все остальное пишется для удобства пользователей.</Callout>

Директория пакета содержит в себе все необходимые данные собираемого пакета, а также ссылки на его зависимости.
При этом сами зависимости также изолированы. Благодаря этой особенности можно использовать сразу нескольких версий одной и той же программы или библиотеки, не вызывая при этом никаких проблем с совместимостью.

Все пакеты Nix являются неизменяемыми (*immutable*), и при обновлении старые пакеты остаются как есть, а для новых создаются директории как было описано ранее.

<Callout>Стоит отметить, что пока существуют поколения которые ссылаются на старые версии пакетов, они не будут удалены из общего хранилища. После ручной или же автоматической очистки старых поколений, директории старых пакетов на которые не будут ссылаться будут удалены.</Callout>

По умолчанию директории всех пакетов Nix находятся по пути `/nix/store/`.
К примеру так может выглядеть полный путь для программы GNU Hello:
`/nix/store/bwacc7a5c5n3qx37nz5drwcgd2lv89w6-hello-2.1.1/bin/hello`

# Атомарные обновления и откаты
Поскольку операции по управлению пакетами никгода не перезаписывают пакеты в хранилище, а просто добавляет новые версии по новым путям, они являются *атомарными*. Это значит, что при обновлениях системы нет состояние "между" - вы либо обновились, либо нет. При резком прерывании обновления, вы **всегда** сможете продолжить его без каких либо ошибок.

А поскольку пакеты не перезаписываются, это значит, что вы всегда можете откатиться к старым версиям:
```shell
$ nix-env --upgrade --attr nixpkgs.some-package
$ nix-env --rollback
```

# Сборка мусора
Когда вы удаляете пакет из системы, он не пропадает из нее насовсем, оставаясь в хранилище. Если вас это раздражает, или вам не хватает места вы можете запустить сборщик мусора:
```shell
$ nix-collect-garbage
```
Это удаляет все пакеты, которые в данный момент не используются в системе.

# Декларативность
Nix использует **декларативную** парадигму управления системой.
То есть пользователь описывает желаемое состояние системы, а пакетник делает все необходимое в соответствии с ранее определенной схемой.

Например, для установки какого-либо ПО или же настройки системы **императивным** способом нам может понадобиться вводить по очередности команды, изменять конфигурационные файлы и так далее. В случае же с декларативным подходом мы заранее определяем что нужно сделать и в какой последовательности, а Nix следует инструкциям для установки или настройки системы/программы как то было задумано. Для определения деклараций пакетов используется одноименный функциональный язык [Nix](/tips/nixlang/introduction).

Nix всеми силами старается убедиться, что выражения детерминированы: выполнение выражения дважды должно дать идентичный результат.

# Управление средами сборки
Nix чрезвычайно полезен всем разработчикам, так как позволяет автоматически настраивать окружение для сборки пакета. Принимая выражение Nix, которое описывает зависимости вашего пакета, команда `nix-shell` создает эти зависимости, если их нет в хранилище, а затем запускает среду с установленными переменными окружения (такие как пути поиска компилятора).

Например, вот процесс получения GNU Hello, распаковки, проверки и сборки:

<Terminal className="terminal">
    <TypingAnimation>$ nix-shell '&lt;nixpkgs&gt;' --attr hello</TypingAnimation>
    <TypingAnimation delay={2500}>[nix-shell]$ unpackPhase</TypingAnimation>
    <AnimatedSpan delay={4000}><span className="text-muted-foreground">unpacking source archive /nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz
    source root is hello-2.12.1</span></AnimatedSpan>
    <TypingAnimation delay={4500}>[nix-shell]$ cd hello-*</TypingAnimation>
    <TypingAnimation delay={6000}>[nix-shell:hello-2.12.1]$ configurePhase</TypingAnimation>
    <AnimatedSpan delay={8500}><span className="text-muted-foreground">patching script interpreter paths in ./configure
    configure flags: --prefix=/nix/store/9bwryidal9q3g91cjm6xschfn4ikd82q-hello-2.12.1
    checking ...
    checking ...</span></AnimatedSpan>
    <TypingAnimation delay={9000}>[nix-shell:hello-2.12.1]$ buildPhase</TypingAnimation>
    <AnimatedSpan delay={10500}><span className="text-muted-foreground">(build output)...</span></AnimatedSpan>
    <TypingAnimation delay={11000}>[nix-shell:hello-2.12.1]$ ./hello</TypingAnimation>
    <AnimatedSpan delay={12500}><span className="text-muted-foreground">Hello, World!</span></AnimatedSpan>
</Terminal>
<br />

# Портативность
Пакетный менеджер Nix может быть также установлен и использован на других дистрибутивах Linux и системах MacOS.
